<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with UI on Physical Wall</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js";
      import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js";

      let scene, camera, renderer;
      let controllerLeft, controllerRight;
      let bullets = [];
      let targets = [];
      const explosionDuration = 0.5;
      const clock = new THREE.Clock();

      // Game state variables
      let timeLeft = 60;
      let score = 0;
      let gameOver = false;

      // --- In-World UI Panel Variables ---
      let uiMesh, uiTexture, uiContext;
      const uiCanvasWidth = 512;
      const uiCanvasHeight = 256;
      // Fallback panel distance if no bounded reference space is available.
      const fallbackPanelDistance = 3; // meters

      function init() {
        // Create the scene.
        scene = new THREE.Scene();

        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0);

        // Create the renderer with alpha (so passthrough shows through).
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create ARButton.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ["hit-test"],
            optionalFeatures: ["dom-overlay"],
            domOverlay: { root: document.body }
          })
        );

        // Add ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Set up controllers.
        controllerLeft = renderer.xr.getController(0);
        controllerLeft.addEventListener("select", onSelect);
        scene.add(controllerLeft);

        controllerRight = renderer.xr.getController(1);
        controllerRight.addEventListener("select", onSelect);
        scene.add(controllerRight);

        // Create initial targets.
        createTargets();

        // Create the in‑world UI panel.
        createUIPanel();

        window.addEventListener("resize", onWindowResize, false);
      }

      function createTargets() {
        // Remove existing targets.
        targets.forEach((target) => scene.remove(target));
        targets = [];

        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 1.0,
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,       // x: between -1 and 1 meters
            1 + Math.random() * 0.5,     // y: roughly eye level
            -2 - Math.random() * 2       // z: 2-4 meters in front
          );
          target.userData.exploding = false;
          target.userData.explodeTime = 0;
          scene.add(target);
          targets.push(target);
        }
      }

      // Computes a position for the UI panel by intersecting a horizontal ray from the camera
      // (in the forward direction) with the boundaries from a bounded reference space.
      // If no valid bounded reference space is available, returns a fallback position.
      function computePanelPositionOnBoundary() {
        const refSpace = renderer.xr.getReferenceSpace();
        // Check if the reference space is valid and has boundsGeometry.
        if (refSpace && refSpace.boundsGeometry && refSpace.boundsGeometry.length > 0) {
          // Convert the bounds (an array of DOMPointReadOnly) to 2D points (Vector2) on the XZ plane.
          const points = refSpace.boundsGeometry.map((pt) => new THREE.Vector2(pt.x, pt.z));
          // Ensure the polygon is closed.
          if (!points[0].equals(points[points.length - 1])) {
            points.push(points[0].clone());
          }

          // Get the camera’s position in the same coordinate space.
          const camPos2D = new THREE.Vector2(camera.position.x, camera.position.z);

          // Compute the camera's forward direction in the horizontal (XZ) plane.
          const forward3D = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const forward2D = new THREE.Vector2(forward3D.x, forward3D.z).normalize();

          let closestT = Infinity;
          let intersection2D = null;

          // For each edge in the bounds polygon, compute intersection with the ray:
          // Ray: R(t) = camPos2D + t * forward2D, t >= 0.
          // Segment: S(u) = p_i + u*(p_i+1 - p_i), u in [0,1].
          for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const s = p2.clone().sub(p1);
            const denominator = forward2D.x * s.y - forward2D.y * s.x;
            if (denominator === 0) continue; // Parallel
            const diff = p1.clone().sub(camPos2D);
            const t = (diff.x * s.y - diff.y * s.x) / denominator;
            const u = (diff.x * forward2D.y - diff.y * forward2D.x) / denominator;
            if (t >= 0 && u >= 0 && u <= 1 && t < closestT) {
              closestT = t;
              intersection2D = camPos2D.clone().add(forward2D.clone().multiplyScalar(t));
            }
          }

          if (intersection2D) {
            // Return the computed position; set y to a fixed value (e.g., 1.6 m).
            return new THREE.Vector3(intersection2D.x, 1.6, intersection2D.y);
          }
        }
        // Fallback: position the panel a fixed distance in front of the camera.
        const fallbackPos = new THREE.Vector3();
        camera.getWorldDirection(fallbackPos);
        fallbackPos.multiplyScalar(fallbackPanelDistance).add(camera.position);
        fallbackPos.y = 1.6;
        return fallbackPos;
      }

      // Creates an in‑world UI panel and places it on the wall.
      function createUIPanel() {
        // Create a canvas element.
        const canvas = document.createElement("canvas");
        canvas.width = uiCanvasWidth;
        canvas.height = uiCanvasHeight;
        uiContext = canvas.getContext("2d");

        // Create a texture from the canvas.
        uiTexture = new THREE.CanvasTexture(canvas);
        uiTexture.encoding = THREE.sRGBEncoding;

        // Create a material for the UI panel.
        const uiMaterial = new THREE.MeshBasicMaterial({
          map: uiTexture,
          transparent: true,
          side: THREE.DoubleSide,
        });

        // Create a plane geometry for the UI panel.
        const uiGeometry = new THREE.PlaneGeometry(1, 0.5); // adjust size (world units) as desired
        uiMesh = new THREE.Mesh(uiGeometry, uiMaterial);

        // Compute the panel position based on the boundaries.
        const panelPos = computePanelPositionOnBoundary();
        uiMesh.position.copy(panelPos);

        // Rotate the panel so that it faces the camera.
        uiMesh.lookAt(camera.position);
        scene.add(uiMesh);
      }

      // Updates the UI panel with the timer and score.
      function updateUIPanel() {
        uiContext.clearRect(0, 0, uiCanvasWidth, uiCanvasHeight);
        uiContext.fillStyle = "rgba(0, 0, 0, 0.6)";
        uiContext.fillRect(0, 0, uiCanvasWidth, uiCanvasHeight);

        uiContext.font = "48px sans-serif";
        uiContext.fillStyle = "white";
        uiContext.textAlign = "left";
        uiContext.fillText("Time: " + Math.floor(timeLeft) + " sec", 20, 80);
        uiContext.fillText("Score: " + score, 20, 150);

        if (gameOver) {
          uiContext.font = "64px sans-serif";
          uiContext.fillStyle = "red";
          uiContext.textAlign = "center";
          uiContext.fillText("GAME OVER", uiCanvasWidth / 2, uiCanvasHeight / 2);
          uiContext.font = "48px sans-serif";
          uiContext.fillText(
            "Tap any controller to Restart",
            uiCanvasWidth / 2,
            uiCanvasHeight / 2 + 60
          );
        }
        uiTexture.needsUpdate = true;
      }

      // Called when a controller "select" event occurs.
      function onSelect(event) {
        // If game over, restart.
        if (gameOver) {
          resetGame();
          return;
        }
        const controller = event.target;
        // Create a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(controller.position);
        scene.add(bullet);

        // Determine forward direction.
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
        bullet.userData.velocity = direction.multiplyScalar(speed);
        bullets.push(bullet);
      }

      function resetGame() {
        timeLeft = 60;
        score = 0;
        gameOver = false;

        // Remove any remaining bullets.
        bullets.forEach((bullet) => scene.remove(bullet));
        bullets = [];

        // Remove existing targets and recreate them.
        targets.forEach((target) => scene.remove(target));
        createTargets();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function render() {
        const delta = clock.getDelta();
        if (!gameOver) {
          timeLeft -= delta;
          if (timeLeft <= 0) {
            timeLeft = 0;
            gameOver = true;
          }
        }

        // Update bullet positions.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        // Check collisions between bullets and targets.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            if (!target.userData.exploding) {
              if (bullet.position.distanceTo(target.position) < 0.28) {
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                score++;
                scene.remove(bullet);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }

        // Animate target explosions.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            const scaleFactor = 1 + progress * 1.5;
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            target.material.opacity = 1 - progress;
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            if (progress >= 1) {
              scene.remove(target);
              targets.splice(i, 1);
            }
          }
        }

        updateUIPanel();
        renderer.render(scene, camera);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
