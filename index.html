<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with Passthrough (No Virtual Floor)</title>
    <style>
      /* Remove default margin and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      // Import Three.js and ARButton as ES modules
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controller;
      let bullets = []; // Track active bullets

      function init() {
        // Create the scene. No background is set so the passthrough will be visible.
        scene = new THREE.Scene();

        // Create a perspective camera. For AR, set near/far values appropriately.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0); // Approximate human eye height

        // Create the WebGL renderer with alpha so the passthrough is visible.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create the ARButton to request an immersive-ar session.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Add some ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // No virtual floor is added since the real-world floor is visible via passthrough.

        // Set up the controller if available.
        // In AR sessions, controllers might not be present; you may add touch or gaze events as a fallback.
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        // Create some sample target objects (floating boxes) as placeholders.
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,     // x: between -1 and 1 meters
            1 + Math.random() * 0.5,   // y: roughly eye level
            -2 - Math.random() * 2     // z: 2-4 meters in front
          );
          scene.add(target);
        }

        // Listen for window resizes.
        window.addEventListener('resize', onWindowResize, false);
      }

      // Event handler: called when a "select" event occurs (e.g., a controller tap or button press).
      function onSelect() {
        // Create a small sphere to represent a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position the bullet at the controller's position if available, or the camera's position.
        if (controller && controller.position) {
          bullet.position.copy(controller.position);
        } else {
          bullet.position.copy(camera.position);
        }
        scene.add(bullet);

        // Determine the forward direction: use the controller’s quaternion if available; otherwise use the camera’s.
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1);
        if (controller && controller.quaternion) {
          direction.applyQuaternion(controller.quaternion);
        } else {
          direction.applyQuaternion(camera.quaternion);
        }
        bullet.userData.velocity = direction.multiplyScalar(speed);

        // Add the bullet to our array so it can be updated each frame.
        bullets.push(bullet);
      }

      // Render loop: update bullet positions and render the scene.
      function render() {
        // Update each bullet's position.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);

          // Remove bullets that have traveled too far.
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        renderer.render(scene, camera);
      }

      // Adjust the scene when the window is resized.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
