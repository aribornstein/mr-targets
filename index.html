<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with Passthrough (No Virtual Floor)</title>
    <style>
      /* Remove default margin and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      // Import Three.js and ARButton as ES modules
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controller;
      let bullets = []; // Track active bullets
      let targets = []; // Track target objects for collision detection
      const explosionDuration = 0.5; // seconds
      const clock = new THREE.Clock(); // Used to track delta time

      function init() {
        // Create the scene. No background is set so the passthrough will be visible.
        scene = new THREE.Scene();

        // Create a perspective camera. For AR, set near/far values appropriately.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0); // Approximate human eye height

        // Create the WebGL renderer with alpha so the passthrough is visible.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create the ARButton to request an immersive-ar session.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Add some ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // No virtual floor is added since the real-world floor is visible via passthrough.

        // Set up the controller if available.
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        // Create some sample target objects (floating boxes) as placeholders.
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            transparent: true, // Enable transparency so we can fade out
            opacity: 1.0
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,     // x: between -1 and 1 meters
            1 + Math.random() * 0.5,   // y: roughly eye level
            -2 - Math.random() * 2     // z: 2-4 meters in front
          );
          // Initialize explosion state variables.
          target.userData.exploding = false;
          target.userData.explodeTime = 0;
          scene.add(target);
          targets.push(target);
        }

        // Listen for window resizes.
        window.addEventListener('resize', onWindowResize, false);
      }

      // Event handler: called when a "select" event occurs (e.g., a controller tap or button press).
      function onSelect() {
        // Create a small sphere to represent a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position the bullet at the controller's position if available, or the camera's position.
        if (controller && controller.position) {
          bullet.position.copy(controller.position);
        } else {
          bullet.position.copy(camera.position);
        }
        scene.add(bullet);

        // Determine the forward direction: use the controller’s quaternion if available; otherwise use the camera’s.
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1);
        if (controller && controller.quaternion) {
          direction.applyQuaternion(controller.quaternion);
        } else {
          direction.applyQuaternion(camera.quaternion);
        }
        bullet.userData.velocity = direction.multiplyScalar(speed);

        // Add the bullet to our array so it can be updated each frame.
        bullets.push(bullet);
      }

      // Render loop: update bullet positions, check collisions, update explosion animations, and render the scene.
      function render() {
        const delta = clock.getDelta();

        // Update bullet positions.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);

          // Remove bullets that have traveled too far.
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        // Check for collisions between bullets and targets.
        // Using a simple sphere collision test: if the distance between the bullet and target
        // is less than a threshold, consider it a hit.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            // Only check targets that are not already exploding.
            if (!target.userData.exploding) {
              // Estimate radii: bullet ~0.02, target ~0.26 (half the box diagonal)
              const distance = bullet.position.distanceTo(target.position);
              if (distance < 0.28) { // 0.02 + 0.26 = 0.28
                // Start explosion animation on the target.
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                // Remove the bullet from the scene and array.
                scene.remove(bullet);
                bullets.splice(i, 1);
                break; // Break out of the target loop once this bullet hits a target.
              }
            }
          }
        }

        // Update explosion animations for targets.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            // Scale up the target (simulate explosion)
            const scaleFactor = 1 + progress * 1.5; // Adjust explosion intensity here.
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            // Fade out the target.
            target.material.opacity = 1 - progress;
            // Optionally, you could add a rotation for extra effect.
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            // Once the explosion animation is complete, remove the target.
            if (progress >= 1) {
              scene.remove(target);
              targets.splice(i, 1);
            }
          }
        }

        renderer.render(scene, camera);
      }

      // Adjust the scene when the window is resized.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
