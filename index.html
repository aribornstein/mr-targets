<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with In-World UI (Timer and Score)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controllerLeft, controllerRight;
      let bullets = [];
      let targets = [];
      const explosionDuration = 0.5;
      const clock = new THREE.Clock();

      // Game state variables
      let timeLeft = 60;
      let score = 0;
      let gameOver = false;

      // --- In-World UI Panel ---
      let uiMesh, uiTexture, uiContext;
      const uiCanvasWidth = 512;
      const uiCanvasHeight = 256;

      function init() {
        // Set up scene
        scene = new THREE.Scene();

        // Set up camera
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0);

        // Set up renderer with XR enabled
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // AR Button
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Ambient light
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Set up controllers (left and right)
        controllerLeft = renderer.xr.getController(0);
        controllerLeft.addEventListener('select', onSelect);
        scene.add(controllerLeft);

        controllerRight = renderer.xr.getController(1);
        controllerRight.addEventListener('select', onSelect);
        scene.add(controllerRight);

        // Create initial targets
        createTargets();

        // Create in‑world UI panel
        createUIPanel();

        // Handle window resize
        window.addEventListener('resize', onWindowResize, false);
      }

      function createUIPanel() {
        // Create a canvas for UI
        const canvas = document.createElement('canvas');
        canvas.width = uiCanvasWidth;
        canvas.height = uiCanvasHeight;
        uiContext = canvas.getContext('2d');

        // Create texture from canvas
        uiTexture = new THREE.CanvasTexture(canvas);
        uiTexture.encoding = THREE.sRGBEncoding;

        // Create a material that renders on top (disable depthTest/depthWrite)
        const uiMaterial = new THREE.MeshBasicMaterial({
          map: uiTexture,
          transparent: true,
          depthTest: false,
          depthWrite: false
        });

        // Create a plane geometry for the UI panel
        const uiGeometry = new THREE.PlaneGeometry(0.8, 0.4); // world units
        uiMesh = new THREE.Mesh(uiGeometry, uiMaterial);
        uiMesh.renderOrder = 9999;

        // Position the UI panel in front of the camera
        // Adjust the position so it appears fixed in the user’s view.
        uiMesh.position.set(0, 0.3, -1);

        // Attach the UI panel to the camera so it moves with the user.
        camera.add(uiMesh);
      }

      // Updates the in-world UI panel with the timer and score
      function updateUIPanel() {
        uiContext.clearRect(0, 0, uiCanvasWidth, uiCanvasHeight);

        // Draw a translucent background
        uiContext.fillStyle = "rgba(0, 0, 0, 0.6)";
        uiContext.fillRect(0, 0, uiCanvasWidth, uiCanvasHeight);

        // Set text style and draw timer and score
        uiContext.font = "48px sans-serif";
        uiContext.fillStyle = "white";
        uiContext.textAlign = "left";
        uiContext.fillText("Time: " + Math.floor(timeLeft) + " sec", 20, 80);
        uiContext.fillText("Score: " + score, 20, 150);

        // If game over, display a message
        if (gameOver) {
          uiContext.font = "64px sans-serif";
          uiContext.fillStyle = "red";
          uiContext.textAlign = "center";
          uiContext.fillText("GAME OVER", uiCanvasWidth / 2, uiCanvasHeight / 2);
          uiContext.font = "48px sans-serif";
          uiContext.fillText("Tap any controller to Restart", uiCanvasWidth / 2, uiCanvasHeight / 2 + 60);
        }

        uiTexture.needsUpdate = true;
      }

      function createTargets() {
        // Remove existing targets (if any)
        targets.forEach(target => scene.remove(target));
        targets = [];

        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 1.0
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          target.position.set(
            Math.random() * 2 - 1,
            1 + Math.random() * 0.5,
            -2 - Math.random() * 2
          );
          target.userData.exploding = false;
          target.userData.explodeTime = 0;
          scene.add(target);
          targets.push(target);
        }
      }

      // Called when a controller "select" event occurs.
      function onSelect(event) {
        // If game over, restart the game on any controller select
        if (gameOver) {
          resetGame();
          return;
        }

        const controller = event.target;
        // Create bullet geometry and material
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(controller.position);
        scene.add(bullet);

        // Determine forward direction from controller orientation
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
        bullet.userData.velocity = direction.multiplyScalar(speed);

        bullets.push(bullet);
      }

      function resetGame() {
        // Reset game variables
        timeLeft = 60;
        score = 0;
        gameOver = false;

        // Remove remaining bullets
        bullets.forEach(bullet => scene.remove(bullet));
        bullets = [];

        // Remove remaining targets and recreate them
        targets.forEach(target => scene.remove(target));
        createTargets();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function render() {
        const delta = clock.getDelta();

        if (!gameOver) {
          timeLeft -= delta;
          if (timeLeft <= 0) {
            timeLeft = 0;
            gameOver = true;
          }
        }

        // Update bullet positions and remove far-away bullets.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        // Check collisions between bullets and targets.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            if (!target.userData.exploding) {
              if (bullet.position.distanceTo(target.position) < 0.28) {
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                score++;
                scene.remove(bullet);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }

        // Handle explosion animations for targets.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            const scaleFactor = 1 + progress * 1.5;
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            target.material.opacity = 1 - progress;
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            if (progress >= 1) {
              scene.remove(target);
              targets.splice(i, 1);
            }
          }
        }

        updateUIPanel();

        renderer.render(scene, camera);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
