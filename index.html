<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with Dynamic Targets</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js";
      import { ARButton } from "https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js";

      let scene, camera, renderer;
      let controllerLeft, controllerRight;
      let bullets = [];
      let targets = [];
      const explosionDuration = 0.5;
      const clock = new THREE.Clock();

      // Game state variables
      let timeLeft = 60;
      let score = 0;
      let gameOver = false;

      // --- In-World UI Panel Variables ---
      let uiMesh, uiTexture, uiContext;
      const uiCanvasWidth = 512;
      const uiCanvasHeight = 256;
      const fallbackPanelDistance = 3; // meters

      function init() {
        // Create the scene.
        scene = new THREE.Scene();

        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0);

        // Create the renderer with alpha (so passthrough shows through).
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create ARButton.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ["hit-test"],
            optionalFeatures: ["dom-overlay"],
            domOverlay: { root: document.body }
          })
        );

        // Add ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Set up controllers.
        controllerLeft = renderer.xr.getController(0);
        controllerLeft.addEventListener("select", onSelect);
        scene.add(controllerLeft);

        controllerRight = renderer.xr.getController(1);
        controllerRight.addEventListener("select", onSelect);
        scene.add(controllerRight);

        // Create initial targets.
        createTargets();

        // Create the in‑world UI panel.
        createUIPanel();

        window.addEventListener("resize", onWindowResize, false);
      }

      function createTargets() {
        // Remove any existing targets.
        targets.forEach((target) => scene.remove(target));
        targets = [];

        // For a starting set, create 5 targets.
        for (let i = 0; i < 5; i++) {
          spawnTarget();
        }
      }

      // Spawns a single target at a random location.
      function spawnTarget() {
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        const targetMaterial = new THREE.MeshStandardMaterial({
          color: Math.random() * 0xffffff,
          transparent: true,
          opacity: 1.0
        });
        const target = new THREE.Mesh(boxGeometry, targetMaterial);
        // Position target randomly within defined ranges.
        // You can adjust these ranges based on your play area.
        target.position.set(
          Math.random() * 2 - 1,          // x between -1 and 1
          1 + Math.random() * 0.5,        // y roughly eye level
          -2 - Math.random() * 2          // z between -2 and -4
        );
        target.userData.exploding = false;
        target.userData.explodeTime = 0;
        scene.add(target);
        targets.push(target);
      }

      // Computes a position for the UI panel by intersecting a horizontal ray from the camera
      // with the boundaries from a bounded reference space.
      // Returns a THREE.Vector3 (in world coordinates). If no intersection is found, returns a fallback position.
      function computePanelPositionOnBoundary() {
        const refSpace = renderer.xr.getReferenceSpace();
        if (refSpace && refSpace.boundsGeometry && refSpace.boundsGeometry.length > 0) {
          const points = refSpace.boundsGeometry.map((pt) => new THREE.Vector2(pt.x, pt.z));
          if (!points[0].equals(points[points.length - 1])) {
            points.push(points[0].clone());
          }

          const camPos2D = new THREE.Vector2(camera.position.x, camera.position.z);
          const forward3D = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
          const forward2D = new THREE.Vector2(forward3D.x, forward3D.z).normalize();

          let closestT = Infinity;
          let intersection2D = null;

          for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            const s = p2.clone().sub(p1);
            const denominator = forward2D.x * s.y - forward2D.y * s.x;
            if (denominator === 0) continue;
            const diff = p1.clone().sub(camPos2D);
            const t = (diff.x * s.y - diff.y * s.x) / denominator;
            const u = (diff.x * forward2D.y - diff.y * forward2D.x) / denominator;
            if (t >= 0 && u >= 0 && u <= 1 && t < closestT) {
              closestT = t;
              intersection2D = camPos2D.clone().add(forward2D.clone().multiplyScalar(t));
            }
          }

          if (intersection2D) {
            return new THREE.Vector3(intersection2D.x, 1.6, intersection2D.y);
          }
        }
        const fallbackPos = new THREE.Vector3();
        camera.getWorldDirection(fallbackPos);
        fallbackPos.multiplyScalar(fallbackPanelDistance).add(camera.position);
        fallbackPos.y = 1.6;
        return fallbackPos;
      }

      // Creates an in‑world UI panel and places it on the wall.
      function createUIPanel() {
        const canvas = document.createElement("canvas");
        canvas.width = uiCanvasWidth;
        canvas.height = uiCanvasHeight;
        uiContext = canvas.getContext("2d");

        uiTexture = new THREE.CanvasTexture(canvas);
        uiTexture.encoding = THREE.sRGBEncoding;

        const uiMaterial = new THREE.MeshBasicMaterial({
          map: uiTexture,
          transparent: true,
          side: THREE.DoubleSide
        });

        const uiGeometry = new THREE.PlaneGeometry(1, 0.5);
        uiMesh = new THREE.Mesh(uiGeometry, uiMaterial);

        const panelPos = computePanelPositionOnBoundary();
        uiMesh.position.copy(panelPos);

        uiMesh.lookAt(camera.position);
        scene.add(uiMesh);
      }

      // Updates the UI panel with the timer and score.
      function updateUIPanel() {
        uiContext.clearRect(0, 0, uiCanvasWidth, uiCanvasHeight);
        uiContext.fillStyle = "rgba(0, 0, 0, 0.6)";
        uiContext.fillRect(0, 0, uiCanvasWidth, uiCanvasHeight);

        uiContext.font = "48px sans-serif";
        uiContext.fillStyle = "white";
        uiContext.textAlign = "left";
        uiContext.fillText("Time: " + Math.floor(timeLeft) + " sec", 20, 80);
        uiContext.fillText("Score: " + score, 20, 150);

        if (gameOver) {
          uiContext.font = "64px sans-serif";
          uiContext.fillStyle = "red";
          uiContext.textAlign = "center";
          uiContext.fillText("GAME OVER", uiCanvasWidth / 2, uiCanvasHeight / 2);
          uiContext.font = "48px sans-serif";
          uiContext.fillText(
            "Tap any controller to Restart",
            uiCanvasWidth / 2,
            uiCanvasHeight / 2 + 60
          );
        }
        uiTexture.needsUpdate = true;
      }

      // Called when a controller "select" event occurs.
      function onSelect(event) {
        if (gameOver) {
          resetGame();
          return;
        }
        const controller = event.target;
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(controller.position);
        scene.add(bullet);

        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1).applyQuaternion(controller.quaternion);
        bullet.userData.velocity = direction.multiplyScalar(speed);
        bullets.push(bullet);
      }

      function resetGame() {
        timeLeft = 60;
        score = 0;
        gameOver = false;

        bullets.forEach((bullet) => scene.remove(bullet));
        bullets = [];

        targets.forEach((target) => scene.remove(target));
        targets = [];
        createTargets();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function render() {
        const delta = clock.getDelta();
        if (!gameOver) {
          timeLeft -= delta;
          if (timeLeft <= 0) {
            timeLeft = 0;
            gameOver = true;
          }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            if (!target.userData.exploding) {
              if (bullet.position.distanceTo(target.position) < 0.28) {
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                score++;
                scene.remove(bullet);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }

        // Animate target explosions.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            const scaleFactor = 1 + progress * 1.5;
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            target.material.opacity = 1 - progress;
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            if (progress >= 1) {
              // Remove the destroyed target.
              scene.remove(target);
              targets.splice(i, 1);
              // Spawn a new target in a random location.
              spawnTarget();
            }
          }
        }

        updateUIPanel();
        renderer.render(scene, camera);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
