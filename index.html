<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with Passthrough on Quest 3</title>
    <style>
      /* Remove default margin and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      // Import Three.js and ARButton as ES modules
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controller;
      let bullets = []; // Track active bullets

      function init() {
        // Create the scene.
        scene = new THREE.Scene();
        // Do not set an explicit background—the passthrough camera feed will serve as the background.

        // Create a perspective camera. (For AR, near/far values are important.)
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 1000);
        camera.position.set(0, 1.6, 0); // approximate human eye height

        // Create the WebGL renderer with alpha so that the AR session can show the passthrough.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create the ARButton. This button will request an immersive-ar session.
        // You can optionally pass sessionInit options. Here we include hit-test support
        // and enable a DOM overlay (which can be useful for UI).
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Add some ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Add a virtual floor. In AR mode the real-world floor is visible via passthrough,
        // so this is only for virtual content reference.
        const floorGeometry = new THREE.PlaneGeometry(10, 10);
        const floorMaterial = new THREE.MeshStandardMaterial({
          color: 0x808080,
          opacity: 0.5,
          transparent: true
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0;
        scene.add(floor);

        // Set up the controller if available.
        // In AR sessions, controllers might not be present;
        // you may wish to fall back to touch or gaze events if needed.
        controller = renderer.xr.getController(0);
        controller.addEventListener('select', onSelect);
        scene.add(controller);

        // Create some sample target objects (floating boxes) that the user can shoot at.
        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,   // x: between -1 and 1 meters
            1 + Math.random() * 0.5, // y: around eye level
            -2 - Math.random() * 2   // z: 2-4 meters in front
          );
          scene.add(target);
        }

        // Listen for window resizes.
        window.addEventListener('resize', onWindowResize, false);
      }

      // Event handler when the controller “selects” (e.g. button pressed or tap detected).
      function onSelect() {
        // Create a small sphere to represent a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position the bullet at the controller's position if available,
        // or fallback to the camera's position.
        if (controller && controller.position) {
          bullet.position.copy(controller.position);
        } else {
          bullet.position.copy(camera.position);
        }
        scene.add(bullet);

        // Determine the forward direction.
        // Use the controller’s quaternion if available; otherwise use the camera’s.
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1);
        if (controller && controller.quaternion) {
          direction.applyQuaternion(controller.quaternion);
        } else {
          direction.applyQuaternion(camera.quaternion);
        }
        bullet.userData.velocity = direction.multiplyScalar(speed);

        // Keep track of the bullet for updates.
        bullets.push(bullet);
      }

      // Render loop: update bullet positions and render the scene.
      function render() {
        // Update each bullet's position.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);

          // Remove bullets that have traveled too far.
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        renderer.render(scene, camera);
      }

      // Adjust the scene when the window is resized.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
