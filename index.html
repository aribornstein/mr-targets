<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with Timer, Points, and Restart</title>
    <style>
      /* Remove default margin and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
      /* UI styling */
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-size: 24px;
        z-index: 999;
        font-family: sans-serif;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 5px;
      }
      /* Restart button styling */
      #restartButton {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 28px;
        padding: 10px 20px;
        z-index: 1000;
        display: none;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- UI for Timer and Score -->
    <div id="ui">
      Time: <span id="timer">60</span> sec<br />
      Score: <span id="score">0</span>
    </div>
    <!-- Restart Button -->
    <button id="restartButton">Restart Game</button>

    <!-- Use ES modules -->
    <script type="module">
      // Import Three.js and ARButton as ES modules
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controllerLeft, controllerRight;
      let bullets = []; // Track active bullets
      let targets = []; // Track target objects for collision detection
      const explosionDuration = 0.5; // seconds
      const clock = new THREE.Clock(); // Used to track delta time

      // Timer and score variables.
      let timeLeft = 60; // seconds
      let score = 0;
      let gameOver = false;
      const timerEl = document.getElementById('timer');
      const scoreEl = document.getElementById('score');
      const restartButton = document.getElementById('restartButton');

      // Setup event listener for restart button.
      restartButton.addEventListener('click', resetGame);

      function init() {
        // Create the scene. No background is set so the passthrough will be visible.
        scene = new THREE.Scene();

        // Create a perspective camera. For AR, set near/far values appropriately.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0); // Approximate human eye height

        // Create the WebGL renderer with alpha so the passthrough is visible.
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create the ARButton to request an immersive-ar session.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Add some ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Set up both left and right controllers.
        controllerLeft = renderer.xr.getController(0);
        controllerLeft.addEventListener('select', onSelect);
        scene.add(controllerLeft);

        controllerRight = renderer.xr.getController(1);
        controllerRight.addEventListener('select', onSelect);
        scene.add(controllerRight);

        // Create initial targets.
        createTargets();

        // Listen for window resizes.
        window.addEventListener('resize', onWindowResize, false);
      }

      // Creates target objects and adds them to the scene and targets array.
      function createTargets() {
        // Clear any existing targets.
        for (const target of targets) {
          scene.remove(target);
        }
        targets = [];

        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 1.0
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,     // x: between -1 and 1 meters
            1 + Math.random() * 0.5,   // y: roughly eye level
            -2 - Math.random() * 2     // z: 2-4 meters in front
          );
          // Initialize explosion state variables.
          target.userData.exploding = false;
          target.userData.explodeTime = 0;
          scene.add(target);
          targets.push(target);
        }
      }

      // Event handler: called when a "select" event occurs on either controller.
      function onSelect(event) {
        if (gameOver) return; // Prevent shooting when game is over.

        // 'event.target' is the controller that triggered the event.
        const controller = event.target;

        // Create a small sphere to represent a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

        // Position the bullet at the controller's position.
        bullet.position.copy(controller.position);
        scene.add(bullet);

        // Determine the forward direction using the controller's quaternion.
        const speed = 0.1;
        const direction = new THREE.Vector3(0, 0, -1);
        direction.applyQuaternion(controller.quaternion);
        bullet.userData.velocity = direction.multiplyScalar(speed);

        // Add the bullet to our array so it can be updated each frame.
        bullets.push(bullet);
      }

      // Render loop: update bullet positions, check collisions, update explosion animations, timer, and render the scene.
      function render() {
        const delta = clock.getDelta();

        // Update timer if the game is not over.
        if (!gameOver) {
          timeLeft -= delta;
          if (timeLeft <= 0) {
            timeLeft = 0;
            gameOver = true;
            // Show the restart button when game over.
            restartButton.style.display = "block";
            console.log("Game Over!");
          }
          timerEl.textContent = Math.floor(timeLeft);
        }

        // Update bullet positions.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);

          // Remove bullets that have traveled too far.
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        // Check for collisions between bullets and targets.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            // Only check targets that are not already exploding.
            if (!target.userData.exploding) {
              // Estimate radii: bullet ~0.02, target ~0.26 (half the box diagonal)
              const distance = bullet.position.distanceTo(target.position);
              if (distance < 0.28) { // 0.02 + 0.26 = 0.28
                // Start explosion animation on the target.
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                // Increase score when a target is hit.
                score++;
                scoreEl.textContent = score;
                // Remove the bullet from the scene and array.
                scene.remove(bullet);
                bullets.splice(i, 1);
                break; // Exit target loop on hit.
              }
            }
          }
        }

        // Update explosion animations for targets.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            // Scale up the target (simulate explosion)
            const scaleFactor = 1 + progress * 1.5;
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            // Fade out the target.
            target.material.opacity = 1 - progress;
            // Add rotation for extra effect.
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            // Once the explosion animation is complete, remove the target.
            if (progress >= 1) {
              scene.remove(target);
              targets.splice(i, 1);
            }
          }
        }

        renderer.render(scene, camera);
      }

      // Resets the game state to allow a new game session.
      function resetGame() {
        // Hide the restart button.
        restartButton.style.display = "none";

        // Reset game variables.
        timeLeft = 60;
        score = 0;
        gameOver = false;
        timerEl.textContent = timeLeft;
        scoreEl.textContent = score;

        // Remove any remaining bullets.
        for (const bullet of bullets) {
          scene.remove(bullet);
        }
        bullets = [];

        // Remove any remaining targets.
        for (const target of targets) {
          scene.remove(target);
        }
        targets = [];

        // Recreate targets.
        createTargets();
      }

      // Adjust the scene when the window is resized.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
