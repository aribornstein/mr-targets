<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mixed Reality FPS with In-World UI and Restart</title>
    <style>
      /* Remove default margin and hide scrollbars */
      body {
        margin: 0;
        overflow: hidden;
      }
    </style>
  </head>
  <body>
    <!-- Use ES modules -->
    <script type="module">
      // Import Three.js and ARButton as ES modules
      import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
      import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/webxr/ARButton.js';

      let scene, camera, renderer;
      let controllerLeft, controllerRight;
      let bullets = []; // Track active bullets
      let targets = []; // Track target objects for collision detection
      const explosionDuration = 0.5; // seconds
      const clock = new THREE.Clock(); // Used to track delta time

      // Game state variables.
      let timeLeft = 60; // seconds
      let score = 0;
      let gameOver = false;

      // --- UI Variables (3D Panels) ---
      let uiMesh, uiContext, uiTexture;
      let restartMesh, restartContext, restartTexture;
      const uiWidth = 256, uiHeight = 128;       // size for the main UI canvas
      const restartWidth = 256, restartHeight = 128; // size for the restart button canvas

      // Raycaster for restart button interaction.
      const raycaster = new THREE.Raycaster();

      function init() {
        // Create the scene.
        scene = new THREE.Scene();

        // Create a perspective camera.
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.01,
          1000
        );
        camera.position.set(0, 1.6, 0); // approximate eye height

        // Create the WebGL renderer with alpha (to allow passthrough).
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // Create the ARButton.
        document.body.appendChild(
          ARButton.createButton(renderer, {
            requiredFeatures: ['hit-test'],
            optionalFeatures: ['dom-overlay'],
            domOverlay: { root: document.body }
          })
        );

        // Add ambient lighting.
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
        hemiLight.position.set(0.5, 1, 0.25);
        scene.add(hemiLight);

        // Set up both controllers.
        controllerLeft = renderer.xr.getController(0);
        controllerLeft.addEventListener('select', onSelect);
        scene.add(controllerLeft);

        controllerRight = renderer.xr.getController(1);
        controllerRight.addEventListener('select', onSelect);
        scene.add(controllerRight);

        // Create initial targets.
        createTargets();

        // Create the in-world UI panels.
        createUIPanels();

        // Listen for window resizes.
        window.addEventListener('resize', onWindowResize, false);
      }

      // Create targets and add them to the scene.
      function createTargets() {
        // Remove any existing targets.
        for (const target of targets) {
          scene.remove(target);
        }
        targets = [];

        const boxGeometry = new THREE.BoxGeometry(0.3, 0.3, 0.3);
        for (let i = 0; i < 5; i++) {
          const targetMaterial = new THREE.MeshStandardMaterial({
            color: Math.random() * 0xffffff,
            transparent: true,
            opacity: 1.0
          });
          const target = new THREE.Mesh(boxGeometry, targetMaterial);
          // Position targets randomly in front of the user.
          target.position.set(
            Math.random() * 2 - 1,     // x: between -1 and 1 meters
            1 + Math.random() * 0.5,   // y: roughly eye level
            -2 - Math.random() * 2     // z: 2-4 meters in front
          );
          target.userData.exploding = false;
          target.userData.explodeTime = 0;
          scene.add(target);
          targets.push(target);
        }
      }

      // Create in-world UI panels (score/timer and restart button) attached to the camera.
      function createUIPanels() {
        // Create main UI canvas (for timer and score).
        const uiCanvas = document.createElement('canvas');
        uiCanvas.width = uiWidth;
        uiCanvas.height = uiHeight;
        uiContext = uiCanvas.getContext('2d');
        uiTexture = new THREE.CanvasTexture(uiCanvas);
        const uiMaterial = new THREE.MeshBasicMaterial({ map: uiTexture, transparent: true });
        const uiGeometry = new THREE.PlaneGeometry(0.5, 0.25); // adjust size in world units
        uiMesh = new THREE.Mesh(uiGeometry, uiMaterial);
        // Position the UI panel in front of the camera.
        uiMesh.position.set(0, 0.2, -1);
        // Make it a child of the camera so it moves with the user.
        camera.add(uiMesh);

        // Create restart button canvas.
        const restartCanvas = document.createElement('canvas');
        restartCanvas.width = restartWidth;
        restartCanvas.height = restartHeight;
        restartContext = restartCanvas.getContext('2d');
        restartTexture = new THREE.CanvasTexture(restartCanvas);
        const restartMaterial = new THREE.MeshBasicMaterial({ map: restartTexture, transparent: true });
        const restartGeometry = new THREE.PlaneGeometry(0.5, 0.25);
        restartMesh = new THREE.Mesh(restartGeometry, restartMaterial);
        // Position the restart button below the main UI.
        restartMesh.position.set(0, -0.3, -1);
        // Initially hide the restart button.
        restartMesh.visible = false;
        camera.add(restartMesh);
      }

      // Update the UI canvases (score/timer and restart button) each frame.
      function updateUI() {
        // Update the main UI canvas.
        uiContext.clearRect(0, 0, uiWidth, uiHeight);
        uiContext.fillStyle = "rgba(0, 0, 0, 0.5)";
        uiContext.fillRect(0, 0, uiWidth, uiHeight);
        uiContext.font = "28px sans-serif";
        uiContext.fillStyle = "white";
        uiContext.fillText("Time: " + Math.floor(timeLeft) + " sec", 10, 40);
        uiContext.fillText("Score: " + score, 10, 80);
        uiTexture.needsUpdate = true;

        // Update the restart button canvas only when game over.
        if (gameOver) {
          restartContext.clearRect(0, 0, restartWidth, restartHeight);
          restartContext.fillStyle = "rgba(200, 0, 0, 0.8)";
          restartContext.fillRect(0, 0, restartWidth, restartHeight);
          restartContext.font = "28px sans-serif";
          restartContext.fillStyle = "white";
          restartContext.textAlign = "center";
          restartContext.fillText("Restart", restartWidth / 2, restartHeight / 2 + 10);
          restartTexture.needsUpdate = true;
          restartMesh.visible = true;
        } else {
          restartMesh.visible = false;
        }
      }

      // Event handler: called when a "select" event occurs on either controller.
      function onSelect(event) {
        const controller = event.target;

        // If game over, check if the restart button was selected.
        if (gameOver) {
          // Set up the raycaster from the controller.
          const tempMatrix = new THREE.Matrix4();
          tempMatrix.identity().extractRotation(controller.matrixWorld);
          const origin = new THREE.Vector3();
          controller.getWorldPosition(origin);
          const direction = new THREE.Vector3(0, 0, -1).applyMatrix4(tempMatrix);
          raycaster.set(origin, direction);
          const intersects = raycaster.intersectObject(restartMesh);
          if (intersects.length > 0) {
            resetGame();
          }
          return;
        }

        // Otherwise, shoot a bullet.
        const bulletGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
        bullet.position.copy(controller.position);
        scene.add(bullet);

        // Determine forward direction.
        const speed = 0.1;
        const directionVec = new THREE.Vector3(0, 0, -1);
        directionVec.applyQuaternion(controller.quaternion);
        bullet.userData.velocity = directionVec.multiplyScalar(speed);
        bullets.push(bullet);
      }

      // Render loop: update bullets, collisions, explosion animations, timer, UI, and render the scene.
      function render() {
        const delta = clock.getDelta();

        if (!gameOver) {
          timeLeft -= delta;
          if (timeLeft <= 0) {
            timeLeft = 0;
            gameOver = true;
            console.log("Game Over!");
          }
        }

        // Update bullet positions.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          bullet.position.add(bullet.userData.velocity);
          if (bullet.position.distanceTo(camera.position) > 20) {
            scene.remove(bullet);
            bullets.splice(i, 1);
          }
        }

        // Check for collisions between bullets and targets.
        for (let i = bullets.length - 1; i >= 0; i--) {
          const bullet = bullets[i];
          for (let j = targets.length - 1; j >= 0; j--) {
            const target = targets[j];
            if (!target.userData.exploding) {
              const distance = bullet.position.distanceTo(target.position);
              if (distance < 0.28) {
                target.userData.exploding = true;
                target.userData.explodeTime = 0;
                score++;
                scene.remove(bullet);
                bullets.splice(i, 1);
                break;
              }
            }
          }
        }

        // Update explosion animations for targets.
        for (let i = targets.length - 1; i >= 0; i--) {
          const target = targets[i];
          if (target.userData.exploding) {
            target.userData.explodeTime += delta;
            const progress = target.userData.explodeTime / explosionDuration;
            const scaleFactor = 1 + progress * 1.5;
            target.scale.set(scaleFactor, scaleFactor, scaleFactor);
            target.material.opacity = 1 - progress;
            target.rotation.x += delta * 2;
            target.rotation.y += delta * 2;
            if (progress >= 1) {
              scene.remove(target);
              targets.splice(i, 1);
            }
          }
        }

        // Update the in-world UI panels.
        updateUI();

        renderer.render(scene, camera);
      }

      // Reset game state for a new session.
      function resetGame() {
        gameOver = false;
        timeLeft = 60;
        score = 0;

        // Remove remaining bullets.
        for (const bullet of bullets) {
          scene.remove(bullet);
        }
        bullets = [];

        // Remove remaining targets.
        for (const target of targets) {
          scene.remove(target);
        }
        targets = [];
        createTargets();
      }

      // Adjust the scene when the window is resized.
      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      init();
      renderer.setAnimationLoop(render);
    </script>
  </body>
</html>
